package db.conn;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DBTest {
//throws = 에러가 발생되는 트라이 구문을 함수 전체로 바라본다. 그 함수 전체 내에서 에러가 발생이 된다 하면 캐치의 역할을 sqlEception으로 보내고 거기서 처리해라.
//장점 : 여러 에러에 대응할 수 있다. 여러 자바 파일에서 throws SQLException만 써주면 저기서 다 해결해 주니까 편하다. , 메모리 누수를 막지 못 한다.
	// 범용적인 에러를 잡을 때 쓴다.
	public static void main(String[] args) throws SQLException{
		
		Connection conn = null;
		String url = "jdbc:oracle:thin:@localhost:1521:orcl";
		
		String user = "myuser";
		String passwd = "1234";
		// 에러가 발생할 수 있는 코드의 범위를 정해준다.트라이 캐치 파이널은 세트로 다닌다, 문제가 없으면 시행 , 오류가 있으면 무조건 catch를 실행 ( 예상치 못 한 에러 발생시 )
		try {
			// 메모리에 뭘 올렸는지 개발자는 알기 때문에 미리 예측되는 에러에 대응하는 코드를 코딩하는 것. 메모리 올리고 비우는 디테일한 에러를 잡을 때 쓴다.
			//첫 줄에서 에러가 발생했다면 두 번째, 세 번째 실행이 안 되고 에러가 발생한 줄에서 바로 catch로 넘어간다.(단점, ex메모리 열어뒀는데 catch로 빠져서 메모리 못 닫는다.)
			//단점 : 캐치에서 모든 에러에 대응을 해야 한다, 에러가 많아지면 코드가 길어진다. 해결하기 위해 throws가 있다 위에 참고.
			//간단한 에러 잡을 때 혹시나 있을 메모리 누수를 막을 때 사용
			//접속을 위해 메모리에 올린다.
			Class.forName("oracle.jdbc.driver.OracleDriver");
			//아래 코드를 통해 
			conn = DriverManager.getConnection(url, user, passwd);
			
			System.out.println("오라클 접속 성공 !!");
			// 자식) 
		}catch (ClassNotFoundException e) {
			System.out.println("오라클 접속 실패");
			System.out.println("ojvdc6.jar 파일에 존재하는 자바 파일을 찾지 못함");
			System.out.println("이유 : " + e.toString());
			//부모) 얘 하나만 있으면 조금 더 디테일하게 에러에 대응할 수 없기 때문에 catch를 여러개 사용한다. 
		}catch (Exception e) {
			System.out.println("오라클 접속 실패 - 최종 Exception까지 호출함");
			System.out.println("이유 : " + e.toString());
			// 필수는 아닌데 무조건 쓰는 걸 추천 (메모리 누수를 막기 위해 ) : 에러 여부와 상관 없이 무조건 실행되는 부분이 finally이다. 
		} finally {
			//메모리에 존재하면 닫아라
			if(conn != null) {
				conn.close();
			}
		}
	conn = null;
	}

}
